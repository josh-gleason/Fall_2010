\begin{enumerate}
\item

The reason that Boolean types are represented on a byte in memory is because in memory, bits do
not have their own addresses.  The smallest memory location that is addressed is a byte.  This
means that although only a bit is needed in theory, in practice this is not realized due to
this hardware limitation.

\item \hspace{1pt}

\lstinputlisting{code.c}

Output:
{\tt \newline 
1.000000 \newline
2.000000 \newline \newline
}
This demonstrates changing the bits in {\tt foo} to represent the {\tt int} values 1065353216
then 1073741824 respectively.  The values are then printed as if the bits represented a {\tt
float} rather than an {\tt int}.  The bit value for 1065353216 as a 32-bit {\tt int} is

{\tt 0011 1111 1000 0000 0000 0000 0000 0000}

which in floating point is $2^{01111111_2 - 127_{10}} = 2^0 = 1$

The second value is

{\tt 0100 0000 0000 0000 0000 0000 0000 0000}

which in floating point is $2^{1000000_2 - 127_{10}} = 2^1 = 2$

(Note: Assumes 32-bit {\tt float} and {\tt int} types)

\item
\begin{enumerate}
\item
{\tt a,b,c} and {\tt d} are all structural equivalence to each other.
\item
{\tt a} and {\tt b} are strict name equivalence to each other, {\tt c} and {\tt d} are not.
\item
{\tt a,b} and {\tt c} are loose name equivalences to each other, {\tt d} is not.

\end{enumerate}

\item
Although memory is allocated for an instance of {\tt Foo} in the {\tt allocate\_node} function,
the parameter is passed by value and therefore, the address of the allocated memory is lost when
the function ends.  In the main function {\tt p} still contains the garbage value that it was
initialized to by default. The program is attempting to de-reference a garbage memory location
which is what causes the run-time error.

\lstinputlisting{code2.c}

By passing an address of a pointer (double pointer) the {\tt Foo} pointer value can be modified.
In {\tt main} the address of {\tt p} is passed using the {\tt address of (\&)} operator.

\end{enumerate}
